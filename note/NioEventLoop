// 新建两个线程池
NioEventLoopGroup#NioEventLoopGroup()
    // 这里的会有SelectorProvider=SelectorProvider.provider()， SelectStrategy=DefaultSelectStrategyFactory, 还有一个拒绝策略=RejectedExecutionHandlers.reject()
    NioEventLoopGroup#NioEventLoopGroup(int, java.util.concurrent.Executor, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategyFactory)
        // 这里的线程数量， 是根据服务器的cpu数量来的
        // DefaultEventExecutorChooserFactory.INSTANCE, 这个是线程选择的策略
        MultithreadEventLoopGroup#MultithreadEventLoopGroup(int, java.util.concurrent.Executor, java.lang.Object...)
            // 这里的executor为null
            MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutorChooserFactory, java.lang.Object...)
                // 给这个executor赋值， 就是ThreadPerTaskExecutor, 新建线程的工厂newDefaultThreadFactory
                // children, 它就是一个线程池的数组
                // 这个children=NioEventLoop, 它就会去新建这个NioEventLoop了
                    // 这个NioEventLoop持有这个group, 选择器， 选择策略, selectProvider, 新建两个队列
                    // 初始化其父类
                        // SingleThreadEventLoop, tailTask一个集合
                            // SingleThreadEventExecutor, executor, taskQueue, rejectedExecutionHandler
                                // AbstractScheduledEventExecutor
                                    // AbstractEventExecutor, 在这里持有了其父类， 也就是group
                    // 打开选择器【这里是简单的一句话， 但是里面的内容挺多的， 这里有个疑难点， 这里， netty对selector里进行了优化， 把netty的selectedKeys给放置了进去， 并对其数据结构进行了修改】
                // 初始化这个选择器， 这个选择器中持有这个children， 它的作用就是去这个线程池里选择一个线程
                // 给每个线程， 添加一个关闭时的监听器
                // 把这个children给转换成一个不可变量


ServerBootstrap
    // 它父boos接收连接事件， 其实只会有一个线程来处理连接事件的， 不会有多个的， workerGroup也就是children线程池， 那么就是处理io事件的线程池
    // 创建一个， 通过反射创建Channel的工厂
    // 设置属性到options中去
    // 设置属性到childOption
    // 设置一个ChannelInitial， inBoundHanderAdapter

// 绑定
io.netty.bootstrap.AbstractBootstrap#bind(int)
    io.netty.bootstrap.AbstractBootstrap#doBind
        initAndRegister, 初始化和注册
            创建一个Channel
                创建一个原始的NioServerSocketChannel
                    AbstractNioMessageChannel, 这里感兴趣的事件， 是连接事件
                        AbstractNioChannel, 持有这个ServerChannel, 并且设置为false
                            AbstractChannel, id, unsafe=NioMessageUnsafe, pipeline=DefaultChannelPipeline, 这个pipeline持有这个channel
                NioServerSocketChannelConfig, 这个配置， 持有这个Netty的Channel, 原始的channel
            初始化
                给这个Channel设置一些属性
                这个Channel中也有一个pipeline， 给这个pipeline添加一个ServerStrapHandler， 这个Handler就是接收一个新的客户端的NioSocketChannel的
                这里的有一个回调方法， 只是暂时的把这个handler添加进去了，只有真正的添加时， 才会再去调用 <============================================sync
                然后添加进去的任务什么时候执行呢？【pipeline.addLast(new ServerBootstrapAcceptor(】 <=========================================sync-4
            将这个Channel注册到一个boosGroup的线程中去
                这里会添加一个任务到集合中去， register0(promise); <==========================================sync-1
                    pipeline.invokeHandlerAddedIfNeeded();此时挂起的任务就会执行了， 就是刚才添加ServerStapHandler的那个
                    下一步， 就尝试， 去设置， 那个提前返回值为true， 那么会再去唤醒任务了
        在返回值里， 添加一个监听器, 这里回调， 这个里的绑定方法
            这里又添加了一个任务io.netty.bootstrap.AbstractBootstrap#doBind0， 这里是增加的第二个任务了 <=================================sync-2
                唤醒后又添加一个 【regFuture.addListener(new ChannelFutureListener() {】<================================================sync-3
                唤醒后又添加一个 【channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);】<================================================sync-4
                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE)
                        io.netty.channel.AbstractChannel.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)
                            io.netty.channel.DefaultChannelPipeline.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)
                                io.netty.channel.AbstractChannelHandlerContext.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise), 这里是TailContext
                                    io.netty.channel.AbstractChannelHandlerContext.invokeBind, HeadContext
                                        io.netty.channel.DefaultChannelPipeline.HeadContext.bind
                                            io.netty.channel.AbstractChannel.AbstractUnsafe.bind此时， 又加入一个以后执行的任务【pipeline.fireChannelActive();】



bind后， 还没有真的绑定成功， 还有一些任务在待执行的集合中， 这里是提前返回一个值， 又会注册一个监听器
        如果成功的话， 干xxx， 否则xxx <======================================sync


添加监听器的时候， 也会去唤醒一些任务