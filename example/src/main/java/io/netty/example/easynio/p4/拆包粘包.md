我们知道， 尽管我们在应用层面使用了netty， 但是对于操作系统来说， 只认TCP协议， 尽管我们的应用层是按照ByteBuf为单位来发送数据， 但是到了底层操作系统仍然是按照字节流发送数据， 因此， 数据到了服务端， 也是按照字节流的方式流入， 然后到了netty应用层面， 重新拼装成Bytebuf， 而这里的ByteBuf与客户端按顺序发送的ByteBuf可能是不对等的。因此， 我们需要在客户端根据自定义协议来组装我们应用层的数据包， 然后在服务端根据我们的应用层的协议来组装数据包， 这个过程通常在服务端称为拆包， 而在客户端称为粘包。

拆包和粘包是相对的， 一端粘了包， 另外一端就需要将粘过的包拆开， 举个例子， 发送端 三个数据 粘成两个TCP数据 包发送到接收端， 接收端就需要根据应用协议将两个数据包重新组装成三个数据 包

拆包的原理：
  在没有netty的情况下， 用户如果自己需要拆包， 基本原理 就是不断从TCP缓冲区中读取数据， 每次读取完都需要判断是否是一个完整的数据 包：

1. 如果当前读取的数据不足以拼接成一个完整的业务 数据包 ， 那就保留该数据， 继续从TCP缓冲区中读取， 直到得到 一个完整的数据包；
2. 如果当前读到的数据加上已经读取的数据足够拼接成一个数据 包， 那就将已经读取的数据拼接上本次读取的数据， 构成一个完整的业务 数据包传递到业务逻辑， 多余的数据仍然保留， 以便和下次读取的数据尝试拼接。

如果我们自己实现拆包， 这个过程 将会非常麻烦， 我们的每一种自定义协议， 都需要自己实现， 还需要考虑各种异常， 而netty自带的一些开箱即用的拆包器已经完全满足我们的需求了， 下面我们来介绍一下netty有哪些自带的拆包器。


netty自带的拆包器
1. 固定长度的拆包器FixedLengthFrameDecoder
<br>
如果你的应用层协议非常简单， 每个数据包的长度都 是固定的， 比如100， 那么只需要把这个拆包器加到pipeline中， netty会把一个个长度为100的数据包ByteBuf传递到下一个ChannelHandler
2. 行拆包器LineBaseFrameDecoder<br/>
以换行符作为分隔符
3. 分隔符拆包器DelimiterBasedFrameDecoder， 可以自定义分隔符
4. 基于长度域拆包器LengthFieldBasedFrameDecoder
5. f
6. f
7. f
8. f